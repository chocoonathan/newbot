import io
import os
import random
import traceback
from uuid import uuid4

import aiofiles
from bs4 import BeautifulSoup
from geopy.geocoders import Nominatim
from pyrogram.errors import MessageTooLong

from clients import bot
from config import API_BOTCAHX, API_MAELYN
from database import state
from helpers import HTML, ButtonUtils, Emoji, Tools, animate_proses

MAX_MEDIA_PER_BATCH = 7


MAX_CAPTION_LENGTH = 700

RANDOM_PANTUN = [
    "Percintaan",
    "Bijak",
    "Masa Depan",
    "Motivasi",
    "Jenaka",
    "Nasihat",
    "Agama",
    "Random",
]

DEFAULT_CERPEN_IMAGE = "https://files.catbox.moe/hnjkpt.jpg"

CERITA_TYPES = {
    "cerpenremaja": "remaja",
    "cerpenanak": "anak",
    "cerpenmisteri": "misteri",
    "cerpenbudaya": "budaya",
    "cerpenromantis": "romantis",
    "cerpengalau": "galau",
    "cerpengokil": "gokil",
    "cerpeninspiratif": "inspiratif",
    "cerpenkehidupan": "kehidupan",
    "cerpensastra": "sastra",
    "cerpenjepang": "jepang",
    "cerpenkorea": "korea",
    "cerpenkeluarga": "keluarga",
    "cerpenpersahabatan": "persahabatan",
    "cerpenkristen": "kristen",
    "cerpenramadhan": "ramadhan",
    "cerpenliburan": "liburan",
    "cerpenlingkungan": "lingkungan",
    "cerpenmengharukan": "mengharukan",
}


def split_message(text, length=824):
    return [text[i : i + length] for i in range(0, len(text), length)]


async def alkitab_cmd(client, message):
    em = Emoji(client)
    await em.get()

    proses = await animate_proses(message, em.proses)
    prompt = client.get_text(message)
    if not prompt:
        return await proses.edit(f"{em.gagal}**Please give me a word.**")

    url = f"https://alkitab.me/search?q={prompt}"
    response = await Tools.fetch.get(url)
    if response.status_code != 200:
        return await proses.edit(f"{em.gagal}**Please try again later!!**")

    soup = BeautifulSoup(response.text, "html.parser")
    result = []

    try:
        for div in soup.find_all("div", class_="vw"):
            a_tag = div.find("a")
            p_tag = div.find("p")

            if not a_tag or not p_tag:
                continue

            link = a_tag.get("href", "#")
            title = a_tag.get_text(strip=True)
            teks = p_tag.get_text(strip=True)

            result.append({"teks": teks, "link": link, "title": title})

        if not result:
            return await proses.edit(
                f"{em.gagal}**Tidak ditemukan hasil untuk kata:** `{prompt}`"
            )

        msg = "\n\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n\n".join(
            f"{v['title']} - https://alkitab.me{v['link']}\n{v['teks']}" for v in result
        )

        if len(msg) < 4000:
            return await proses.edit(
                f"{em.sukses}<b>Hasil pencarian:</b>\n\n{msg}",
                disable_web_page_preview=True,
            )

        output = io.BytesIO(msg.encode("utf-8"))
        output.name = f"alkitab_{prompt}.txt"
        await client.send_document(
            message.chat.id,
            output,
            caption=f"{em.sukses} <b>Hasil pencarian kata:</b> <code>{prompt}</code>",
        )
        return await proses.delete()

    except Exception as e:
        return await proses.edit(f"{em.gagal}**Terjadi error:** `{e}`")


async def pantun_cmd(client, message):
    emo = Emoji(client)
    await emo.get()
    cmd = message.command[0].lower()
    input_ = client.get_text(message).lower()

    if not input_:
        input_ = random.choice(RANDOM_PANTUN).lower()

    pros = await message.reply(
        f"{emo.proses}<b>Processing to create {cmd} {input_} ..</b>"
    )
    prompt = f"{cmd} {input_}"
    params = {"q": prompt}
    headers = {"mg-apikey": API_MAELYN}
    r = await Tools.fetch.get(
        "https://api.maelyn.sbs/api/gemini/chat", headers=headers, params=params
    )
    if r.status_code != 200:
        return await pros.edit(f"{emo.gagal}<b>Failed to create {cmd} {input_}.</b>")
    data = r.json()
    return await pros.edit(
        f"{emo.sukses}<b>Successfully generated {cmd} {input_}:\n\n<code>{data.get('result')}</code>\n{emo.profil} Generated by: {client.me.mention}</b>"
    )


async def gen_kdm(text):
    messages = [
        {
            "role": "system",
            "content": "kamu adalah seorang paranormal dari seluruh dunia dan kamu hanya menggunakan bahasa Indonesia",
        },
        {
            "role": "assistant",
            "content": (
                "Anda adalah seorang paranormal yang mampu mendeskripsikan khodam seseorang yang berupa binatang. "
                "Tugas Anda adalah mendeskripsikan khodam yang mungkin ada, termasuk wujud, sifat, dan energi yang dipancarkan. "
                "Sehingga apapun inputnya anggap itu adalah sebuah nama seseorang. Deskripsi tidak harus positif bisa saja negatif tidak masalah "
                "karena ini hiburan. Ini hanya untuk entertainment jadi bebaskan dirimu untuk menjadi seorang paranormal pada umumnya. "
                "Deskripsikan Khodam dengan singkat namun jelas, dan pastikan deskripsi tidak lebih dari 700 karakter alfabet dalam plain text "
                "serta berbahasa Indonesia."
            ),
        },
        {"role": "user", "content": HTML.clean_text(text)},
    ]
    payload = {"message": messages, "apikey": API_BOTCAHX}
    response = await Tools.fetch.post(
        "https://api.botcahx.eu.org/api/search/openai-custom", json=payload
    )
    return response.json()


async def khodam_cmd(client, message):
    em = Emoji(client)
    await em.get()
    nama = client.get_name(message)
    if not nama:
        return await message.reply(
            f"{em.gagal}**Give the name you want to check the Khodam.**"
        )
    pros = await animate_proses(message, em.proses)
    try:
        khodam_result = await gen_kdm(nama)
        if not khodam_result.get("result"):
            return await pros.edit(f"{em.gagal}**Please try again later.**")
        params = {"prompt": HTML.clean_text(khodam_result.get("result"))}
        headers = {"mg-apikey": API_MAELYN}
        r_images = await Tools.fetch.get(
            "https://api.maelyn.sbs/api/blackbox/imagine",
            headers=headers,
            params=params,
        )
        if r_images.status_code != 200:
            teks = f"{em.sukses}<b>Here is the Khodam <code>{nama}</code>:\n\n<blockquote expandable><code>{khodam_result.get('result')}</blockquote></code>\n\n{em.profil} Checked by: {client.me.mention}</b>"
            await message.reply(teks)
            return await pros.delete()
        data = r_images.json()
        images = data["result"]["url"]
        caption = f"{em.sukses}<b>Here is the Khodam <code>{nama}</code>:\n\n<blockquote expandable><code>{khodam_result.get('result')}</code></blockquote>\n\n{em.profil} Checked by: {client.me.mention}</b>"
        await client.send_photo(
            message.chat.id,
            photo=images,
            reply_to_message_id=message.id,
            caption=caption,
        )
        return await pros.delete()

    except Exception as e:
        return await pros.edit(f"{em.gagal} {traceback.format_exc()}")


async def chord_cmd(client, message):
    em = Emoji(client)
    await em.get()
    proses = await animate_proses(message, em.proses)
    prompt = client.get_text(message)
    if not prompt:
        return await proses.edit(
            f"{em.gagal}**Please give me prompt!\nExample: `{message.text.split()[0]} Dear God`.**"
        )
    arg = client.get_text(message)
    payload = {"search": arg}
    url = "https://api.siputzx.my.id/api/s/gitagram"
    respon = await Tools.fetch.post(url, json=payload)
    if respon.status_code != 200:
        return await proses.edit(f"**Please try again later: {respon.status_code}.**")
    data = respon.json()["data"]
    uniq = f"{str(uuid4())}"
    state.set(uniq.split("-")[0], "chord", data)
    inline = await ButtonUtils.send_inline_bot_result(
        message,
        message.chat.id,
        bot.me.username,
        f"inline_chord {uniq.split('-')[0]}",
    )
    if inline:
        return await proses.delete()
    else:
        return await proses.edit(
            f"{em.gagal}**Please try again later: {respon.status_code}!!**"
        )


async def kbbi_cmd(client, message):
    em = Emoji(client)
    await em.get()

    proses = await animate_proses(message, em.proses)
    prompt = client.get_text(message)
    if not prompt:
        return await proses.edit(
            f"{em.gagal}**Please reply to a message containing the prompt!\n"
            f"Example: `{message.text.split()[0]} pohon`**"
        )

    url = f"https://api.maelyn.sbs/api/kbbi?q={prompt}&apikey={API_MAELYN}"
    response = await Tools.fetch.get(url)
    if response.status_code == 200:
        data = response.json()["result"]
        result = "**KBBI Result:**\n\n"

        if "description" in data:
            result += "**Deskripsi:**\n"
            result += f"- {data.get('description')}\n\n"

        if "relatedWords" in data:
            result += "**Kata Dasar Lain:**\n"
            result += ", ".join(data.get("relatedWords")) + "\n\n"

        if "baseWord" in data:
            result += "**baseWord:**\n"
            result += f"- **{data['baseWord']}\n"
        try:
            return await proses.edit(result)
        except MessageTooLong:
            with io.BytesIO(str.encode(str(result))) as out_file:
                out_file.name = f"{prompt}.txt"
                await message.reply_document(document=out_file)
            return await proses.delete()
    else:
        return await proses.edit(f"{em.gagal}**Failed to fetch data from KBBI API!**")


async def ocr_cmd(client, message):
    em = Emoji(client)
    await em.get()
    reply = message.reply_to_message
    if not reply or not reply.photo and not reply.sticker and not reply.animation:
        return await message.reply_text(
            f"{em.gagal}`{message.text.split()[0]}` **reply to media!**"
        )

    proses = await animate_proses(message, em.proses)
    try:
        media_path = await reply.download()
        url_img = await Tools.maelyn_upload(media_path)
        url = f"https://api.maelyn.sbs/api/ocr?url={url_img}&apikey={API_MAELYN}"
        response = await Tools.fetch.get(url)
        if response.status_code != 200:
            return await proses.edit(f"{em.gagal}**Please try again later!**")
        result = response.json().get("result")
        return await proses.edit(f"{em.sukses}<code>{result}</code>")
    except Exception as e:
        return await proses.edit(f"{em.gagal}**ERROR:** {str(e)}")


async def pastebin_cmd(client, message):
    em = Emoji(client)
    await em.get()

    proses = await animate_proses(message, em.proses)
    if not message.reply_to_message:
        return await proses.edit(f"{em.gagal}**Please reply to message!!**")
    r = message.reply_to_message
    if not r.text and not r.document:
        return await proses.edit(
            f"{em.gagal}**Please reply to message text or document!!**"
        )
    if r.text:
        content = str(r.text)
    else:
        if r.document.file_size > 40000:
            return await proses.edit(f"{em.gagal}**Maximum size is 40000!!**")
        doc = await message.reply_to_message.download()
        async with aiofiles.open(doc, mode="r") as f:
            content = await f.read()
        os.remove(doc)
    link = await Tools.paste(content)
    photo = await Tools.screen_web(link, True)
    try:
        await message.reply_document(
            photo, caption=f"{em.sukses}<b>Succesed <a href='{link}'>link</a></b>"
        )
        return await proses.delete()
    except Exception:
        await message.reply(f"{em.sukses}<b>Succesed <a href='{link}'>link</a></b>")
        return await proses.delete()


async def infoanime_cmd(client, message):
    em = Emoji(client)
    await em.get()
    proses = await animate_proses(message, em.proses)
    url = "https://api.siputzx.my.id/api/anime/samehadaku/latest"
    response = await Tools.fetch.post(url)
    if response.status_code != 200:
        return await proses.edit(
            f"{em.gagal}**Please try again later: {response.status_code}!!**"
        )
    data = response.json()["data"]
    uniq = f"{str(uuid4())}"
    state.set(uniq.split("-")[0], "anime", data)
    inline = await ButtonUtils.send_inline_bot_result(
        message,
        message.chat.id,
        bot.me.username,
        f"inline_anime {uniq.split('-')[0]}",
    )
    if inline:
        return await proses.delete()
    else:
        return await proses.edit(
            f"{em.gagal}**Please try again later: {response.status_code}!!**"
        )


async def artiname_cmd(client, message):
    em = Emoji(client)
    await em.get()
    proses = await animate_proses(message, em.proses)
    if message.reply_to_message:
        if message.reply_to_message.sender_chat:
            nama = message.reply_to_message.sender_chat.title
        elif message.reply_to_message.from_user:
            nama = message.reply_to_message.from_user.first_name
            if message.reply_to_message.from_user.last_name:
                nama = f"{message.reply_to_message.from_user.first_name} {message.reply_to_message.from_user.last_name or ''}"
        else:
            return await proses.edit(f"{em.gagal} <b>Name not found!</b>")
    else:
        if len(message.command) < 2:
            return await proses.edit(
                f"{em.gagal}<b>You need to specify a user (either by reply user or give name)!</b>"
            )
        try:
            nama = message.text.split()[1]
        except IndexError:
            return await proses.edit(
                f"{em.gagal} <b>Please reply message or give name.</b>"
            )

    url = f"https://api.siputzx.my.id/api/primbon/artinama?nama={nama}"
    rp = await Tools.fetch.get(url)
    if rp.status_code != 200:
        return await proses.edit(f"{em.gagal} <b>Please try again later.</b>")

    data = rp.json()
    if not data.get("status"):
        return await proses.edit(f"{em.gagal} <b>Name not found in data!</b>")

    nama_res = data["data"]["nama"].title()
    arti_res = data["data"]["arti"]
    catatan_res = data["data"].get("catatan", "")

    reply_text = (
        f"<blockquote expandable>**üîç Arti Nama: {nama_res}**\n\n"
        f"<b>üìñ {arti_res}</b>\n</blockquote>"
    )
    if catatan_res:
        reply_text += f"<b>\nüí° <i>{catatan_res}</i></b>"

    return await proses.edit(reply_text)


async def zodiak_cmd(client, message):
    em = Emoji(client)
    await em.get()
    proses = await animate_proses(message, em.proses)
    ZODIAK_LIST = [
        "aries",
        "taurus",
        "gemini",
        "cancer",
        "leo",
        "virgo",
        "libra",
        "scorpio",
        "sagitarius",
        "capricorn",
        "aquarius",
        "pisces",
    ]
    if len(message.command) < 2:
        return await proses.edit(
            f"{em.gagal}**Please give zodiak name\n\n<code>{', '.join([z.capitalize() for z in ZODIAK_LIST])}</code>**"
        )
    try:
        query = message.text.split(None, 1)[1].strip().lower()
    except IndexError:
        return await proses.edit(
            f"{em.gagal} <b>Please give zodiak name!\n\nExample:</b> <code>{message.text.split()[0]} gemini</code>"
        )
    if query not in ZODIAK_LIST:
        return await proses.edit(
            f"{em.gagal} <b>Zodiak not found!</b>\n\n"
            f"<b>Daftar Zodiak:</b>\n"
            f"<code>{', '.join([z.capitalize() for z in ZODIAK_LIST])}</code>"
        )
    url = f"https://api.siputzx.my.id/api/primbon/zodiak?zodiak={query}"
    rp = await Tools.fetch.get(url)

    if rp.status_code != 200:
        return await proses.edit(f"{em.gagal} <b>Gagal mengambil data dari API.</b>")

    data = rp.json()
    if not data.get("status"):
        return await proses.edit(
            f"{em.gagal} <b>Data tidak ditemukan untuk zodiak ini.</b>"
        )

    z = data["data"]
    teks = (
        f"<b>‚ôà Zodiak:</b> {z['zodiak']}\n"
        f"<b>üî¢ Nomor Keberuntungan:</b> {z['nomor_keberuntungan']}\n"
        f"<b>üå∏ Aroma Keberuntungan:</b> {z['aroma_keberuntungan']}\n"
        f"<b>ü™ê Planet Penguasa:</b> {z['planet_yang_mengitari']}\n"
        f"<b>üåº Bunga Keberuntungan:</b> {z['bunga_keberuntungan']}\n"
        f"<b>üé® Warna Keberuntungan:</b> {z['warna_keberuntungan']}\n"
        f"<b>üíé Batu Keberuntungan:</b> {z['batu_keberuntungan']}\n"
        f"<b>üå™Ô∏è Elemen:</b> {z['elemen_keberuntungan']}\n\n"
        f"<b>‚ù§Ô∏è Pasangan Zodiak & Kepribadian:</b>\n<blockquote>{z['pasangan_zodiak']}</blockquote>"
    )

    return await proses.edit(f"<blockquote expandable>{teks}</blockquote>")


async def tafsir_cmd(client, message):
    em = Emoji(client)
    await em.get()
    proses = await animate_proses(message, em.proses)

    prompt = client.get_text(message)
    if not prompt:
        return await proses.edit(
            f"{em.gagal} <b>Enter the dream text to interpret.</b>"
        )

    url = f"https://api.siputzx.my.id/api/primbon/tafsirmimpi?mimpi={prompt}"
    response = await Tools.fetch.get(url)
    if response.status_code != 200:
        return await proses.edit(
            f"{em.gagal} <b>Server is having problems, please try again later.</b>"
        )

    data = response.json().get("data")
    if not data:
        return await proses.edit(f"{em.gagal} <b>Data not found.</b>")

    keyword = data.get("keyword", "Tidak diketahui")
    hasil_list = data.get("hasil", [])
    total = data.get("total", "0")
    solusi = data.get("solusi", "")

    hasil_teks = ""
    if hasil_list:
        hasil_teks = "\n".join(f"‚Ä¢ {item}" for item in hasil_list)
    else:
        hasil_teks = "<i>(There is no direct interpretation for this dream.)</i>"

    solusi_teks = solusi.strip().replace("      ", "").replace("\n", "\n")

    teks = (
        f"<b>üåô Tafsir Mimpi</b>\n\n"
        f"<b>üîë Keyword:</b> {keyword}\n"
        f"<b>üìä Total Ditemukan:</b> {total}\n\n"
        f"<b>üìñ Hasil Tafsir:</b>\n{hasil_teks}\n\n"
        f"<b>üí° Solusi:</b>\n<blockquote expandable>{solusi_teks}</blockquote>"
    )

    return await proses.edit(teks)


async def maps_cmd(client, message):
    em = Emoji(client)
    await em.get()
    proses = await animate_proses(message, em.proses)
    prompt = client.get_text(message)
    if not prompt:
        return await proses.edit(
            f"{em.gagal} <b>Please specify location!!\nExample: `{message.text.split()[0]} Ceger, Pondok Aren Tangerang Selatan</b>"
        )
    try:
        geolocator = Nominatim(user_agent="User")
        geoloc = geolocator.geocode(prompt)
        if geoloc:
            lon = geoloc.longitude
            lat = geoloc.latitude
            share = await message.reply_location(latitude=lat, longitude=lon)
            await message.reply(
                f"{em.sukses}**Location for: `{prompt}`.**",
                reply_to_message_id=share.id,
            )
        else:
            await message.reply(
                f"{em.gagal}**Addres not found!! Please input a valid address.**"
            )
    except Exception as er:
        await message.reply(f"{em.gagal}**ERROR:** {str(er)}")
    return await proses.delete()
